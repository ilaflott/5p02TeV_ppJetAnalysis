// Originally Written By Jennifer Coulter
// July 22nd 2015
// Destroyed by Ian Laflotte
// May 1st 2016
//
// Test macro for plotting thrust, an event shape variable.
//

//C includes			    
#include <cstdlib>		    
#include <stdio.h>		    
#include <iostream>		    
#include <fstream>		    
#include <sstream>		    
#include <cmath>		    
				    
//load/read/write		    
#include <TSystem.h>		    
#include <TProfile.h>		    
#include <TFile.h>		    
#include <TTree.h>		    
#include <TNtuple.h>		    
#include <TEventList.h>		    
				    
//utilities			    
#include <TChain.h>		    
#include <TCut.h>		    
#include <TMath.h>		    
#include <TRandom3.h>		    
#include <TVector3.h>		    
#include <TStopwatch.h>		    

//plotting			    
#include <TStyle.h>		    
#include <TCanvas.h>		    
#include <TGraphErrors.h>	    
#include <TGraphAsymmErrors.h>	    
#include <TLegend.h>		    
#include <TLatex.h>		    
#include <TLine.h>		    

//histos				    
#include <TH1.h>		    
#include <TF1.h>		    
#include <TH2.h>		    
#include <TH3.h>		    
#include <TH1F.h>		    
#include <TH1F.h>		    
#include <TH2F.h>                   

using namespace std;

//plane class, feel like i should put this in its own header
class Plane{
public:

  TVector3 v1, v2, proj, u1, u2;
  Double_t scalar1, scalar2, mag1, mag2; 

  Plane(TVector3);

  //returns a projection onto the 2D plane 
  TVector3 Projection(TVector3 jaxis){

    //Find the projection of a jet onto this subspace
    if(v1.Mag() == 0) { scalar1 = 0; } else { scalar1 = jaxis.Dot(v1)/(v1.Dot(v1)); } 
    if(v2.Mag() == 0) { scalar2 = 0; } else { scalar2 = jaxis.Dot(v2)/(v2.Dot(v2)); } 

    v1 = scalar1*v1;
    v2 = scalar2*v2;

    proj(0) = v1(0) + v2(0);
    proj(1) = v1(1) + v2(1);
    proj(2) = v1(2) + v2(2); 
    
    return proj;
  }//end of projection
};

//plane class constructor
Plane::Plane(TVector3 nT){
  
  //Use TVector3 to find an orthogonal vector and a second vector orthogonal to the first and nT
  v1 = nT.Orthogonal();  v2 = nT.Cross(v1);

  //Normalize, checking for 0 length axes, v1 first
  if ((v1(0) == 0) && (v1(1) == 0) && (v1(2) == 0))  { 
    v1(0) = 0;    v1(1) = 0;    v1(2) = 0; 
  }
  else { 
    mag1 = v1.Mag();   v1(0) = v1(0)/mag1;    v1(1) = v1(1)/mag1;    v1(2) = v1(2)/mag1; 
  } 

  //then v2
  if ((v2(0) == 0) && (v2(1) == 0) && (v2(2) == 0))  { 
    v2(0) = 0;    v2(1) = 0;    v2(2) = 0; 
  } 
  else { 
    mag2 = v2.Mag();   v2(0) = v2(0)/mag2;    v2(1) = v2(1)/mag2;    v2(2) = v2(2)/mag2; 
  }

}//end plane constructor

//creates histograms in terms of Thrust vs. dN/dT
TH1F* DivideByBinWidth(TH1F * hist, const char * name){

  TH1F* h_return = new TH1F(name, "", hist->GetNbinsX(), 0,1);
  hist->Sumw2(); 

  //loops through all the bins
  for (int i=1;i<=hist->GetNbinsX();++i){
    Float_t bin = hist->GetBinWidth(i);
    Float_t val = hist->GetBinContent(i);
    Float_t valErr = h_return->GetBinError(i);
    val = val/bin;
    valErr= valErr/bin;
    h_return->SetBinError(i,valErr);
    h_return->SetBinContent(i, val); 
  }//end bin loop

  return h_return;
}//end rebin function

//Function to normalize a vector
TVector3 Norm(TVector3 v){

  //check for zero components
  if ( (v(0) == 0) && (v(1) == 0) && (v(2) == 0) ) return v; 

  //do magnitude + normalize
  Double_t mag = TMath::Sqrt(v(0)*v(0) + v(1)*v(1) + v(2)*v(2)); 
  v(0) = v(0)/mag;    v(1) = v(1)/mag;   v(2) = v(2)/mag;

  return v; 
}//end normalize

//plot thrust
//void thrust_HiForest(Int_t startfile, Int_t endfile, Int_t jobNumber){

void thrust_HiForest(Int_t startfile = 0,  Int_t endfile = 45,  Int_t radius = 3,
		     std::string kFoname="test_output.root", std::string kFoname2="bad_output.root",
		     float ptCut = 30.0, float etaCut = 2.0){

  TH1::SetDefaultSumw2();
  
  bool debug = false;
  //Float_t pT_cut = 30;
  //Int_t radius = 3;

  //define trees and file
  TFile * file; 
  TFile * weight_file;

  TTree * t;
  TTree * hiEvt;
  //TTree * hlt;
  TTree * skim;
  TTree * weight;
  TTree * thrust_tree;

  TStopwatch timer;

  /*
  //set up the tree to be filled
  thrust_tree->Branch("pthatweight",&pthatweight,"pthatweight/D");
  thrust_tree->Branch("hiBin",&hiBin,"hiBin/I");
  thrust_tree->Branch("evt",&evnt,"evt/I");
  thrust_tree->Branch("lumi",&lumi,"lumi/I");
  thrust_tree->Branch("vz",&vz,"vz/F");
  */


  //Tree variables
  Float_t pt[1000];    Int_t jt80;   Int_t jt80_pre;
  Float_t eta[1000];   Int_t jt40;   Int_t jt60_pre;
  Float_t phi[1000];   Int_t jt60;   Int_t jt40_pre;

  // Double_t px[1000];
  // Double_t py[1000];
  // Double_t pz[1000];
  
  //event info
  Int_t nref;
  Float_t vz;
  Int_t halo;
  Int_t noise;

  //pthat info
  Double_t pThat_weight;
  Float_t pThat; 

  //vector computations
  Float_t dot = 0;
  Double_t mag = 0;
  Double_t thrust_temp = 0;
  Double_t thrust_max = 0;
  Double_t dot_maj = 0;
  Double_t dot_min = 0;
  Double_t min_temp = 0;
  Double_t maj_temp = 0;
  Double_t thrust_maj_max =0;
  Double_t thrust_min_max = 0;
  TVector3 max_thrust_axis;
  TVector3 p3Norm;
  //Float_t max_eta = 0;   Float_t temp_eta = 0;  
  //Float_t max_phi = 0;   Float_t temp_phi = 0;

  Int_t max_nref;
  Int_t jetCount = 0; //in order to sum up the number of jets per event
  Int_t eventCount = 0;//check to see how many of the events in each file are actually being used

  //define input file list and instream for that file list
  string input_file = "jetRAA_pp_data_forest.txt"; 
  ifstream count(input_file.c_str(), ifstream::in);

  //count up the total number of files and save their names to an array of filenames for initialization purposes
  string * filename = new string[135];
  string line;
  Int_t fileCount = 0;
  while(getline(count, line)){
    filename[fileCount] = line;
    if (debug) cout << filename[fileCount] << endl; 
    fileCount++;
  }
  count.close();
  
  //open the save file, rewrite it if it's already existing
  TFile * save_File = new TFile(kFoname.c_str(),"RECREATE");
  save_File->cd();
  
  //book histograms
  TH1F * h_thrust = new TH1F("thrust_unscaled", "", 50,0,1);
  TH1F * h_min = new TH1F("thrust_min", "", 50,0,1);
  TH1F * h_maj = new TH1F("thrust_maj", "", 50,0,1);
  TH1F * h_pT = new TH1F("pT", "", 100, 0, 120);
  TH1F * h_pTcut = new TH1F("pTcut", "", 100, 0, 120);
  //TH1F * h_40 = new TH1F("thrust_40", "", 50,0,1);
  //TH1F * h_60 = new TH1F("thrust_60", "", 50,0,1);
  //TH1F * h_80 = new TH1F("thrust_80", "", 50,0,1);
  TH1F * h_nref = new TH1F("nref", "", 12, 0, 12);
  TH1F * h_jetCount = new TH1F("jetCount", "", 12, 0, 12);
  TH1F * h_eta = new TH1F("eta", "", 60, -2, 2);
  TH1F * h_phi = new TH1F("phi", "", 60, -3.15, 3.15);
  TH1F * h_weight = new TH1F("weighting", "", 500, 0, 500);
  
  //book "bad" histograms
  TH1F * h_TBad = new TH1F("thrust_bad", "", 50,0,1);
  TH1F * h_TminBad = new TH1F("thrust_min_bad", "", 50,0,1);
  TH1F * h_TmajBad = new TH1F("thrust_maj_bad", "", 50,0,1);
  TH1F * h_TBadpT = new TH1F("TBadpT", "", 100, 0, 120);
  TH1F * h_TmajBadpT = new TH1F("TmajBadpT", "", 100, 0, 120);
  TH1F * h_TminBadpT = new TH1F("TminBadpT", "", 100, 0, 120);
  TH1F * h_etaBad = new TH1F("etaBad", "", 60, -2, 2);
  TH1F * h_phiBad = new TH1F("phiBad", "", 60, -3.15, 3.15);
  TH1F * h_nrefBad = new TH1F("nrefBad", "", 12, 0, 12);
  TH1F * h_jetCountBad = new TH1F("jetCountBad", "", 12, 0, 12);
  TH1F * h_weightBad = new TH1F("weightingBad", "", 500, 0, 500);
  TH1F * h_pthatBad = new TH1F("pthatBad", "", 500, 0, 500);
  TH1F * h_fileNum = new TH1F("fileNum", "", 45, 0, 45);
  
  // For every file in file list, process trees
  for(int ifile = startfile; ifile < endfile; ifile++){
    
    //open file
    string s = filename[ifile];
    file = TFile::Open(s.c_str());

    //open weight file
    string w = Form("weights_pp_%d.root", ifile+1); 
    weight_file = TFile::Open(w.c_str());

    if (debug) {
      cout << "\n **** =========================== New File ================================= **** \n ";
      cout << "File Name: " << filename[ifile] << endl; 
      cout << "File Number: " << endfile-ifile << "/" << endfile-startfile << endl;
      cout << "Weight File: " << w << endl;
    }

    //get trees from the file and set the branch addresses
    t = (TTree*)file->Get(Form("ak%dPFJetAnalyzer/t", radius));
    t->SetBranchAddress("jtpt", &pt);
    t->SetBranchAddress("jteta", &eta);
    t->SetBranchAddress("jtphi", &phi);
    t->SetBranchAddress("nref", &nref);
    t->SetBranchAddress("pthat", &pThat);

    hiEvt = (TTree*)file->Get("hiEvtAnalyzer/HiTree");
    hiEvt->SetBranchAddress("vz", &vz);

    skim = (TTree*)file->Get("skimanalysis/HltTree");
    //skim->SetBranchAddress("pHBHENoiseFilter", &noise);
    skim->SetBranchAddress("pPAcollisionEventSelectionPA",&halo);

    //hlt = (TTree*)file->Get("hltanalysis/HltTree");  
    //hlt->SetBranchAddress("HLT_PAJet80_NoJetID_v1",&jt80);
    //hlt->SetBranchAddress("HLT_PAJet60_NoJetID_v1",&jt60);
    //hlt->SetBranchAddress("HLT_PAJet40_NoJetID_v1",&jt40);
    //hlt->SetBranchAddress("HLT_PAJet80_NoJetID_v1_Prescl",&jt80_pre);
    //hlt->SetBranchAddress("HLT_PAJet60_NoJetID_v1_Prescl",&jt60_pre);
    //hlt->SetBranchAddress("HLT_PAJet40_NoJetID_v1_Prescl",&jt40_pre);

    weight = (TTree*)weight_file->Get("weights");
    weight->SetBranchAddress("pthatweight", &pThat_weight);

    t->AddFriend(hiEvt);
    t->AddFriend(skim);
    //t->AddFriend(hlt);
    t->AddFriend(weight);
    
    Long64_t nentries = t->GetEntries();
    cout << "Events in File: " << nentries << endl;
    if(debug) nentries = 100;    

    //event loop begins
    for(Long64_t nentry = 0; nentry<nentries; ++nentry){
      //for(Long64_t nentry = 6662; nentry<6663; ++nentry){
      
      if( debug && nentry%10000==0 ) cout << "nentry=" << nentry << endl;
      
      t->GetEntry(nentry);
      skim->GetEntry(nentry);
      hiEvt->GetEntry(nentry);
      weight->GetEntry(nentry);
      
      //make selection cuts
      if(TMath::Abs(vz) > 15 || halo == 0) continue;

      ///////
      jetCount = 0;
      bool select = false;
      ///////

      //fill pThat spectra plot
      h_weight->Fill(pThat, pThat_weight); 
      
      // get the pt vector for each event which passes you jet selections based on pT and eta
      vector <float> pt_v;
      vector <float> eta_v;
      vector <float> phi_v;

      for(int ij = 0; ij<nref; ++ij) {
	if(pt[ij] > ptCut && fabs(eta[ij]) < etaCut) {
	  pt_v.push_back(  pt[ij]  );	
	  eta_v.push_back( eta[ij] );	
	  phi_v.push_back( phi[ij] );	
	}
      }

      if (debug) cout<<"Total Number of Jets    : "<<nref<<endl;
      if (debug) cout<<"Number of Selected Jets : "<<pt_v.size()<<endl;

      int NJets_Sel = pt_v.size();
      if(NJets_Sel < 2 && debug) {
	cout<<"This event had only 1 Jet"<<endl;
	continue;	
      }
      
      // //intial pT cut
      // for(int k = 0; k < nref; k++){
      // 	if(pt[k] >  30){
      // 	  if((TMath::Abs(eta[k])<2)) select = true; 
      // 	}
      // }

      // if(!select) continue;
      if(debug) cout<< " \n ******* New Event ******** " << endl;
      if(debug) cout<< " ******* " << nentry << " ******** " << endl;
      
      //reset maximum values
      eventCount++;
      thrust_max = 0;

      vector <double> px;
      vector <double> py;
      vector <double> pz;
      
      for(Long64_t naxis = 0; naxis < NJets_Sel; ++naxis){
	float axis_jet_pt = pt_v[naxis];
	float axis_jet_eta = eta_v[naxis];
	float axis_jet_phi = phi_v[naxis];
      	px.push_back( (double)axis_jet_pt * TMath::Cos(axis_jet_phi)  );
	py.push_back( (double)axis_jet_pt * TMath::Sin(axis_jet_phi)  );
	pz.push_back( (double)axis_jet_pt * TMath::SinH(axis_jet_eta) );

	if(py[naxis] == 0 && debug) {
	    cout << "PYZERO" << endl; 
	    cout << "Jet Variables: "<< "\n \t pT = "<<axis_jet_pt<<"\n \t eta = "<<axis_jet_eta<<"\n \t phi = "<<axis_jet_phi<<endl;
	  }
      }

      //PART 1 ====================================================
      //Runs through all the jets in an event, checking them to see if they are the axis that maximizes thrust
      //max axis finding loop
      for(Long64_t naxis = 0; naxis < NJets_Sel; ++naxis){

	float axis_jet_pt = pt_v[naxis];
	float axis_jet_eta = eta_v[naxis];
	float axis_jet_phi = phi_v[naxis];
	
	//Cut checks
	//if(debug) cout<< "Jet Variables: "<< "\n \t pT = "<<axis_jet_pt<<"\n \t eta = "<<axis_jet_eta<<"\n \t phi = "<<axis_jet_phi<<endl;
	// h_pT->Fill(pt[naxis]);

	// if((pt[naxis] < pT_cut)||(TMath::Abs(eta[naxis]) > 2)) {
	//   continue;
	// }
	h_pTcut->Fill(axis_jet_pt);
	
	// jetCount++; 
	
	if(debug) cout<< " \n --------- New Test Axis (Thrust)--------- " << endl; 
	
	//reset values for this particular event
	thrust_temp = 0;  // maj_temp = 0;   min_temp = 0;
	
	// px[naxis] = pt[naxis]*TMath::Cos(phi[naxis]);
	// py[naxis] = pt[naxis]*TMath::Sin(phi[naxis]);
	// pz[naxis] = pt[naxis]*TMath::SinH(eta[naxis]);
	
	//calculates axis for this particular jet
	TVector3 nT (px[naxis], py[naxis], pz[naxis]);
	if(debug) cout<<"Test Axis Unnormed = {" << nT(0) << ", " << nT(1) << ", " << nT(2)<< "}" << endl;
	nT = Norm(nT);
	
	if(debug) cout<<"Test Axis = {" << nT(0) << ", " << nT(1) << ", " << nT(2)<< "}" << endl;
	//temp_phi = axis_jet_phi;   temp_eta = axis_jet_eta;
	
	//resets for next jet loop
	dot = 0;   mag = 0;

	//PART 2 ====================================================
	//Loops through all the jets to find the thrust value for the chosen axis 
	//jet loop
	for(Long64_t njet = 0; njet < NJets_Sel; ++njet){
	  
	  // if((pt[njet] < pT_cut)||(TMath::Abs(eta[njet]) > 2)){ continue;}
	  float jet_pt = pt_v[njet];
	  float jet_eta = eta_v[njet];
	  float jet_phi = phi_v[njet];
	
	  if(debug) cout<< " \n --------- New Jet (Thrust)--------- " << endl; 
	  if(debug) cout<< "Jet Variables: "<< "\n \t pT = "<<jet_pt<<"\n \t eta = "<<jet_eta<<"\n \t phi = "<<jet_phi<<endl;
	  
	  //calculate px, py, pz
	  // px[njet] = pt[njet]*TMath::Cos(phi[njet]);
	  // py[njet] = pt[njet]*TMath::Sin(phi[njet]); 
	  // pz[njet] = pt[njet]*TMath::SinH(eta[njet]);
	
	  //define momentum three vector
	  TVector3 p3 (px[njet], py[njet], pz[njet]);
	  //TVector3 p3Norm = Norm(p3);
	  
	  if(debug) cout<<"Jet Axis = {" << p3(0) << ", " << p3(1) << ", " << p3(2)<< "}" << endl;
	  
	  //dots the two vectors for Thrust, Tmin and Tmaj
	  dot += TMath::Abs(p3.Dot(nT)); 
	  if(debug) cout<<"dot sum = " << dot << endl;
	  
	  //sum the total p from the individual p magnitudes
	  mag += TMath::Abs(p3.Mag());
	  if(debug) cout<<"mag sum = " << mag << endl;
	  
	}//end jet loop
	
	//calculate the thrust
	thrust_temp = ((dot)/mag);
	
	//Compare to see if this axis is a new maximum 
	if(debug) cout<< "\ntemp thrust = " << thrust_temp << endl; 
	
	if(thrust_temp>thrust_max){
	  thrust_max = thrust_temp;
	  max_thrust_axis = nT;
	  //max_eta = temp_eta;
	  //max_phi = temp_phi;
	  max_nref = naxis;
	  
	}
	if(debug) cout<< "max thrust = " << thrust_max << endl;
	
      }//end axis loop
      
      if (debug) cout << "FINAL THRUST VALUE: " << thrust_max << endl; 
      
      // FILL BAD THRUST VALUES TO DEBUG =============================
      if(thrust_max < 0.47) {
	
	//h_TBadpT->Fill(pt[naxis], pThat_weight);
	h_TBad->Fill(thrust_max, pThat_weight);
	h_etaBad->Fill(eta_v[max_nref],pThat_weight);
	h_phiBad->Fill(phi_v[max_nref], pThat_weight);
	h_nrefBad->Fill(max_nref);
	h_jetCountBad->Fill(NJets_Sel);
	h_weightBad->Fill(pThat_weight);
	h_pthatBad->Fill(pThat);
	h_fileNum->Fill(ifile);

	if (debug) cout << "______________________________" << endl; 
	if (debug) cout << "| X0X : THRUST LESS THAN 0.5 |" << endl;
	if (debug) cout << "|  Max Thrust: " << thrust_max << endl;
	//cout << "|  Max Thrust: " << thrust_max << endl;
	if (debug) cout << "______________________________" << endl; 
      }
      
      //PART 3 ====================================================
      //Begin code to select the Thrust Major and Minor axes
      
      //define the plane perpendicular to this axis in order to calculate Tmaj and Tmin
      Plane* perp = new Plane(max_thrust_axis);
      
      //reset maximum values for new axis test
      thrust_maj_max = 0;   thrust_min_max = 0; 
      
      //Thrust maj axis loop
      for(Long64_t naxis = 0; naxis < NJets_Sel; ++naxis){

	// if((pt[naxis] < pT_cut)||(TMath::Abs(eta[naxis]) > 2)){ continue;}
	if(debug) cout<< " \n --------- New Test Axis (Min/Maj)--------- " << endl; 
	
	//define the jet axis for this iteration
	//calculate px, py, pz
	// px[naxis] = pt[naxis]*TMath::Cos(phi[naxis]);
	// py[naxis] = pt[naxis]*TMath::Sin(phi[naxis]); 
	// pz[naxis] = pt[naxis]*TMath::SinH(eta[naxis]);
	
	//define momentum three vector
	TVector3 p3 (px[naxis], py[naxis], pz[naxis]);
	if(debug) cout<<"Jet Axis UnNormed = {" << p3(0) << ", " << p3(1) << ", " << p3(2)<< "}" << endl;
	p3 = Norm(p3);
	if(debug) cout<<"Jet Axis Normed = {" << p3(0) << ", " << p3(1) << ", " << p3(2)<< "}" << endl;
	
	//define maj_axis and min_axis 
	TVector3 maj_axis = perp->Projection((p3));
	if(debug) cout<<"Maj Axis UnNormed = {" << maj_axis(0) << ", " << maj_axis(1) << ", " << maj_axis(2)<< "}" << endl;
	maj_axis = Norm(maj_axis);
	TVector3 min_axis = max_thrust_axis.Cross(maj_axis);
	min_axis = Norm(min_axis); 
	
	if(debug) cout<<"Jet Axis = {" << p3(0) << ", " << p3(1) << ", " << p3(2)<< "}" << endl;
	if(debug) cout<<"Maj Axis = {" << maj_axis(0) << ", " << maj_axis(1) << ", " << maj_axis(2)<< "}" << endl;
	if(debug) cout<<"Min Axis = {" << min_axis(0) << ", " << min_axis(1) << ", " << min_axis(2)<< "}\n" << endl;
	
	//reset for new axis test
	dot_maj = 0;   dot_min = 0;   mag = 0;

	//PART 4 ====================================================
	//Test the axis defined by the above loop to determine if this axis is the maximum
	//jet loop
	for(Long64_t njet = 0; njet < NJets_Sel; ++njet){
	  
	  //make a ptcut
	  // if((pt[njet] < pT_cut)||(TMath::Abs(eta[njet]) > 2)){ continue;}
	  float jet_pt = pt_v[njet];
	  float jet_eta = eta_v[njet];
	  float jet_phi = phi_v[njet];
	  
	  if(debug) cout<< " \n --------- New Jet (Maj/Min)--------- " << endl; 
	  //if(debug) cout<< "Jet Variables: "<< "\n \t pT = "<<pt[njet]<<"\n \t eta = "<<eta[njet]<<"\n \t phi = "<<phi[njet]<<endl;
	  if(debug) cout<< "Jet Variables: "<< "\n \t pT = "<<jet_pt<<"\n \t eta = "<<jet_eta<<"\n \t phi = "<<jet_phi<<endl;

	  //calculate px, py, pz
	  // px[njet] = pt[njet]*TMath::Cos(phi[njet]);
	  // py[njet] = pt[njet]*TMath::Sin(phi[njet]); 
	  // pz[njet] = pt[njet]*TMath::SinH(eta[njet]);
	  
	  //define momentum three vector
	  TVector3 p3 (px[njet], py[njet], pz[njet]);
	  TVector3 p3Norm = Norm(p3);
	  
	  if(debug) cout<<"Jet Axis = {" << p3(0) << ", " << p3(1) << ", " << p3(2)<< "}" << endl;
	  
	  //dots the two vectors for Tmin and Tmaj
	  dot_maj += TMath::Abs(p3.Dot(maj_axis)); 
	  dot_min += TMath::Abs(p3.Dot(min_axis));
	  if(debug) cout<<"dot maj sum = " << dot_maj << endl;
	  if(debug) cout<<"dot min sum = " << dot_min << endl;
	  
	  //sum the total p from the individual p magnitudes
	  mag += TMath::Abs(p3.Mag());
	  if(debug) cout<<"mag sum = " << mag << endl;
	  
	}//end jet loop

	//calculate the thrust major and minor for this axis
	maj_temp = dot_maj/mag;
	min_temp = dot_min/mag;
	
	//test to to see if this particular Tmaj and Tmin are the new maxima
	if(maj_temp>thrust_maj_max){
	  thrust_maj_max = maj_temp;  
	  thrust_min_max = min_temp; 
	  if(debug) cout << "thrust major max = "<< thrust_maj_max<< endl;
	  /*
	    if(maj_temp > 0.5) {
	    h_TmajBadpT->Fill(pt[naxis]);
	    h_TmajBad->Fill(maj_temp);
	    } 
	    if(min_temp > 0.5) {
	    h_TminBadpT->Fill(pt[naxis]);
	    h_TminBad->Fill(maj_temp);
	    } 
	  */
	}   
      }//end of major/minor axis loop
      timer.Stop();
      
      //fill all the maximum values before finishing
      // if(jetCount > 1){
	
      h_thrust->Fill(thrust_max, pThat_weight);
      h_eta->Fill(eta_v[max_nref], pThat_weight);
      h_phi->Fill(phi_v[max_nref], pThat_weight);
      h_min->Fill(thrust_min_max, pThat_weight);
      h_maj->Fill(thrust_maj_max, pThat_weight);
      h_nref->Fill(nref);
      h_jetCount->Fill(NJets_Sel);
	
      if(debug) {
	if (thrust_max < 0.5)     {  cout << "FLAG_thrust1: " << thrust_max <<  " , " << jetCount << endl; }
	if (thrust_maj_max > 0.5) {  cout << "FLAG_maj: " << thrust_maj_max <<  " , " << jetCount << endl; }
	if (thrust_min_max > 0.5) {  cout << "FLAG_min: " << thrust_min_max <<  " , " << jetCount << endl; }
      }	
      //if(jt80)    h_80->Fill(thrust_max,jt80_pre * pThat_weight);
      //if(jt60)    h_60->Fill(thrust_max,jt60_pre * pThat_weight);
      //if(jt40)    h_40->Fill(thrust_max,jt40_pre * pThat_weight);
      //}

      pt_v.clear();
      eta_v.clear();
      phi_v.clear();

      px.clear();
      py.clear();
      pz.clear();
      
    }//end of event loop


    
    gROOT->GetListOfFiles()->Remove(file);
    gROOT->GetListOfFiles()->Remove(weight);
    
    cout << "Events Selected: " << eventCount << endl;
    cout << "File Finished" << endl; 
    
  }//end file loop

  //scale the histograms
  Double_t integral;
  
  // integral = h_thrust->Integral();
  // h_thrust->Scale(1/integral);
  //h_thrust->Scale(1./h_thrust->Integral());
  //h_maj->Scale(1./h_maj->Integral());
  //h_min->Scale(1./h_min->Integral());

  // integral = h_maj->Integral(); 
  // h_maj->Scale(1/integral);

  // integral = h_min->Integral();
  // h_min->Scale(1/integral);

  //integral = h_80->Integral();
  //h_80->Scale(integral);

  //integral = h_60->Integral();
  //h_60->Scale(integral);

  // integral = h_40->Integral();
  //h_40->Scale(integral); 
 
  //Create the plot for Thrust vs. dN/dT
  //define histograms
  TH1F * h_T = DivideByBinWidth(h_thrust, "thrust_scaled");
  TH1F * h_Tmaj = DivideByBinWidth(h_maj, "thrust_maj_scaled");
  TH1F * h_Tmin = DivideByBinWidth(h_min, "thrust_min_scaled");
  
  //Float_t divEntries = 1./(h_thrust->GetBinWidth(1));
  
  //h_T->Scale(divEntries);
  //h_Tmaj->Scale(divEntries);
  //h_Tmin->Scale(divEntries);
  
  //h_40 = DivideByBinWidth(h_40, "thrust_40_new");   h_40->Scale(divEntries);
  //h_60 = DivideByBinWidth(h_60, "thrust_60_new");   h_60->Scale(divEntries);
  //h_80 = DivideByBinWidth(h_80, "thrust_80_new");   h_80->Scale(divEntries);

  h_T->Print("base");
  h_Tmaj->Print("base");
  h_Tmin->Print("base");
  h_pT->Print("base");
  h_pTcut->Print("base");
  //h_40->Print("base");
  //h_60->Print("base");
  //h_80->Print("base");
  h_nref->Print("base");
  h_jetCount->Print("base");
  h_eta->Print("base");
  h_phi->Print("base");
  h_weight->Print("base"); 
  
  h_T->Write();
  h_Tmaj->Write();
  h_Tmin->Write();
  h_pT->Write();
  h_pTcut->Write();
  //h_40->Write();
  //h_60->Write();
  //h_80->Write();
  h_nref->Write();
  h_jetCount->Write();
  h_eta->Write();
  h_phi->Write();
  h_weight->Write(); 
  
  save_File->Write();
  save_File->Close();

  cout<<endl<<endl<<endl<<endl<<"GOING TO WRITE BAD OUTPUT FILE"<<endl<<endl<<endl<<endl;
  
  //if(debug) {
    
  TFile * bad_File = new TFile(kFoname2.c_str(),"RECREATE");
  
  bad_File->cd();
  
  h_TBad->Print("base");
  h_TmajBad->Print("base");
  h_TminBad->Print("base");
  h_TBadpT->Print("base");
  h_TmajBadpT->Print("base");
  h_TminBadpT->Print("base");
  h_etaBad->Print("base");
  h_phiBad->Print("base");
  h_nrefBad->Print("base");
  h_jetCountBad->Print("base");
  h_pthatBad->Print("base");
  h_weightBad->Print("base");
  h_fileNum->Print("base"); 
    
  h_TBad->Write();
  h_TmajBad->Write();
  h_TminBad->Write();
  h_TBadpT->Write();
  h_TmajBadpT->Write();
  h_TminBadpT->Write();
  h_etaBad->Write();
  h_phiBad->Write();
  h_nrefBad->Write();
  h_jetCountBad->Write();
  h_pthatBad->Write();
  h_weightBad->Write();
  h_fileNum->Write();
    
  bad_File->Write();
  bad_File->Close();
  // }
  
  timer.Stop();
  cout<<"Macro finished: "<<endl;
  
  cout<<"CPU time (min)  = "<<(Float_t)timer.CpuTime()/60<<endl;
  cout<<"Real time (min) = "<<(Float_t)timer.RealTime()/60<<endl;
  
}//end of plot thrust
